# -*- coding: utf-8 -*-
"""mnist classifier1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/116hPCYns8I1ZB3Xl1ePWHEx8CGKOZ2JJ
"""

from __future__ import print_function
import argparse
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torchvision import datasets,  transforms
import torchvision
import matplotlib.pyplot as plt
import numpy as np
import tqdm
import glob
from matplotlib import pyplot as plt
from skimage import data
from skimage.feature import blob_dog, blob_log, blob_doh
from math import sqrt
from skimage.color import rgb2gray
import glob
from skimage.io import imread

class Net(nn.Module):
    
    def __init__(self):
        super().__init__()
        self.pad1 = nn.ZeroPad2d(2)
        self.conv1 = nn.Conv2d(1, 6, 5, bias = False)
        self.conv2 = nn.Conv2d(6, 16, 5, bias = False)
        self.conv3 = nn.Conv2d(16, 120, 5, bias = False)
        self.fc1 = nn.Linear(120, 84)
        self.fc2 = nn.Linear(84, 20)
        
    def forward(self, x):
        x = self.pad1(x)
        x = F.avg_pool2d(F.relu(self.conv1(x)), 2)
        x = F.avg_pool2d(F.relu(self.conv2(x)), 2)
        x = F.relu(self.conv3(x))
        x = x.view(-1, 120)
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        x = F.log_softmax(x, dim = 1)
        return x

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
# device = torch.device('cpu')
print(device)

model = Net().to(device)
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr = 0.01)

transform = transforms.Compose([transforms.ToTensor()])

trainset = datasets.MNIST(root='./data', train=True,
                                        download=True, transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, batch_size=64,
                                          shuffle=True, num_workers=2)

testset = datasets.MNIST(root='./data', train=False,
                                       download=True, transform=transform)
testloader = torch.utils.data.DataLoader(testset, batch_size=64,
                                         shuffle=False, num_workers=2)



for i, data in enumerate(trainloader):
    inputs, labels = data
    print(inputs.shape)
    print(labels.shape)
    break

model.train()
for epoch in range(2):
    
    running_loss = 0.0
    for i, data in tqdm.tqdm(enumerate(trainloader)):
        
        inputs, labels = data[0].to(device), data[1].to(device)
        optimizer.zero_grad()
        
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        
        running_loss += loss.item()
        if(i%2000 ==1999):
            print('[%d %5d] loss: %.7f' % (epoch+1, i+1, running_loss/2000))
        running_loss = 0.0    
        
print('Finished Training')

model.eval()
class_correct = list( 0.0 for i in range(10))
class_total = list(0.0 for i in range(10))
correct = 0.0
total = 0.0


with torch.no_grad():
  for data in testloader:
    input, labels = data[0].to(device), data[1].to(device)
    output_raw = model(input)
    output = torch.argmax(output_raw,1)
    c = (output == labels)
    
    for i in range(4):
      label = labels[i]
      class_correct[label] += c[i].item()
      class_total[label] += 1
      correct += c[i].item()
      total +=1
      

for i in range(10):
    print('Accuracy of %1d : %2d %%' % (
        i, 100 * class_correct[i] / class_total[i]))
    
print ('accuracy of test set is %2.2f %%' % (correct/total*100))

def imshow(img):
#     img = img / 2 + 0.5     # unnormalize
    npimg = img.numpy()
    plt.imshow(np.transpose(npimg, (1, 2, 0)))
    plt.show()

dataiter = iter(testloader)

input, labels = dataiter.next()
imshow(torchvision.utils.make_grid(input))
print(labels)
print
output = model(input.to(device))
print(output)

out = torch.argmax(output, 1)
print(out)

print(out.to('cpu') == labels)

input  = glob.glob(r"/content/drive/My Drive/workspace/images/banter-snaps-5CPIzjWzGxo-unsplash.jpg")[0]
im = imread(input, as_grey=True)
img =torch.from_numpy(im)

imshow(torchvision.utils.make_grid(img))
img.reshape(6,1,5,5)
output = model(img.to(device))
print(output)

from google.colab import drive
drive.mount('/content/drive')